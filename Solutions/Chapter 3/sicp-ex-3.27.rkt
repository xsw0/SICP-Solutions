#lang sicp
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup . keys)
      (define (iter keys table)
        (if (null? keys)
            (cdr table)
            (let ((subtable (if (list? table)
                                (assoc (car keys) (cdr table))
                                #f)))
              (if subtable
                  (iter (cdr keys) subtable)
                  false))))
      (iter keys local-table))
    (define (insert! value . keys)
      (define (make keys)
        (if (null? keys)
            value
            (list (cons (car keys) (make (cdr keys))))))
      (define (iter keys table)
        (if (null? keys)
            (set-cdr! table value)
            (let ((subtable (if (list? table)
                                (assoc (car keys) (cdr table))
                                #f)))
              (if subtable
                  (iter (cdr keys) subtable)
                  (set-cdr! table
                            (if (list? (cdr table))
                                (cons (cons (car keys)
                                            (make (cdr keys)))
                                      (cdr table))
                                (make keys)))))))
      (iter keys local-table)
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup) lookup)
            ((eq? m 'insert!) insert!)
            ((eq? m 'value) local-table)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))
(define (lookup x table) ((table 'lookup) x))
(define (insert! x table) ((table 'insert!) x))

(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
(define memo-fib
  (memoize (lambda (n)
             (cond ((= n 0) 0)
                   ((= n 1) 1)
                   (else (+ (memo-fib (- n 1))
                            (memo-fib (- n 2))))))))
(define (memoize f)
  (let ((table (make-table)))
    (lambda (x)
      (let ((previously-computed-result (lookup x table)))
        (or previously-computed-result
            (let ((result (f x)))
              (insert! x result table)
              result))))))